Репозитории:
1. мапа вида string: specialObject
2. find по id
3. добавление?




пока попробуем концепцию при создании объекта user, lection они в констуктор



// Надо раскрыть в классы
enum SubjectType
{
    Exam,
    Pass
}




public Main()
{

UserRepository userRepository = new UserRepository(); // см. пункт 9
//userRepository.Add(new User("Mayatin");     // cм. пункт 8
//userRepository.Add(new User("Khartanovich");

User currentUser = userRepository.Get("Mayatin"); // См. пункт 3

EducationProgramsRepository EPRepository = new EducationProgrammRepository();
EducationProgramBuilder epBuilder = new EducationProgramBuilder();
EPRepository.Add(epBuilder.SetName("IS").SetNumberOfSemesters(4).SetAuthor(currentUser).Build()); // См. пункт 11

SubjectRepository subjectRepository = new SubjectRepository();
SubjectBuilder algo = new SubjectBuilder()
SubjectBuilder english = new SubjectBuilder();
SubjectRepository.Add(algoBuilder.SetName("Algo").SetSubjectType(SubjectType.Exam).SetAuthor(currentUser).Build());
SubjectRepository.Add(algoBuilder.SetName("English").SetSubjectType(SubjectType.Pass).SetAuthor(currentUser).Build());
SubjectRepository.CloneAndAdd("Algo", "Discrete");   // См. пункт 10
SubjectRepository.Find("Discrete").ChangeSubjectType(SubjectType.Pass);

// Development
SubjectRepository subjectRepository = new SubjectRepository();
ISubjectFactory examFactory = new SubjectExamFactory();
ISubjectFactory passFactory = new SubjectPassFactory();
subjectRepository.Add(examFactory.CreateExamSubject("Algo", currentUser, 20));
subjectRepository.Add(passFactory.CreatePassSubject("English", currentUser));
SubjectRepository.CloneAndAdd("Algo", "Discrete");   // См. пункт 10
SubjectRepository.Find("Discrete").ChangeSubjectType(SubjectType.Pass);



//



currentUser = userRepository.Get("Khartanovich"); // См. пункт 3

LectionRepository lectionRepository = new LectionRepository();
LectionBuilder algoLectionOne = new LectionBuilder();
LectionBuilder algoLectionTwo = new LectionBuilder();
lectionRepository.Add(algoLectionOne.SetName("Lection Number One").SetBrief("Something Useful").SetContent("blablabla").SetAuthor(currentUser))
lectionRepository.CloneAndAdd("Lection Number One", "Lection Number Two");

SubjectRepository.Find("Algo").AddLection(lectionRepository.Find("Lection Number One"));
SubjectRepository.Find("Algo").AddLection(lectionRepository.Find("Lection Number Two"));



// Labwork... the same



// А что если мы будем добавлять предметы в оп в самом конце и когда происходит добавление, то оп будет чекать 100 баллов ли там или нет?
EducationUnitBuilder algoUnit = new EducationUnitBuilder();
EducationUnitBuilder englishUnit = new EducationUnitBuilder();
EducationUnitBuilder discreteUnit = new EducationUnitBuilder();
EPRepository.Find("IS").AddSubject(algoUnit.SetSubject(SubjectRepository.Find("Algo").SetSemestr(1).build(););
EPRepository.Find("IS").AddSubject(englishUnit.SetSubject(SubjectRepository.Find("English").SetSemestr(1).build(););
EPRepository.Find("IS").AddSubject(discreteUnit.SetSubject(SubjectRepository.Find("Discrete").SetSemestr(2).build(););

epRepository.Find("IS").AddSubjectToSemester(SubjectRepository.Find("Algo"), 1)
epRepository.Find("IS").AddSubjectToSemester(SubjectRepository.Find("English"), 1)
epRepository.Find("IS").AddSubjectToSemester(SubjectRepository.Find("Discrete"), 1)

}


!!!!!! ИНДЕИ !!!!!!!
1. А что если мы будем добавлять предметы в оп в самом конце и когда происходит добавление, то оп будет чекать 100 баллов ли там или нет?
2. Надо раскрыть enum SubjectType в классы
        Кол-во баллов должно быть unmutable - бизнес-логикка
3. А что если ввести в тестах (ну или в продакшене) переменную User currentUser, которая будет отвечать за то, под каким юзером идет редактирование?
       Это позволит не вводить постоянно пользователя плюс упростить проверку на то, кто редактирует
4. Нужно сохранить единый класс Subject, при этом, чтобы в клонированном объекте было parentId
        поэтому заюзаем nullable-поле: public int? ParentId
5. Очень не нравится, что для каждого поля свой метод. Билдер?
6. Насчет невозможность изменять некоторые поля после клонирования: а что если основной смысл клонирования будет в том, что
        действительно мы не можем изменять неизменяемые поля, поэтому и делаем например лабу на основе другой,
        а поля для изменения будут действительно изменяться
7. Можно для User сделать паттерн singleton, чтобы обеспечить глобальную точку доступа к currentUser. тогда не нужно будет передавать постоянно currentuser
8. Add должен принимать IUser, чтобы поддерживать расширимость до Admin условно
9. Сделать из репозиториев Controllers из grasp? Чтобы методы find, add и clone делегировались другим классам
10. Так однозначно и не решил: клонирование - это ответственность репозитория или нет?
        Subject discrete = SubjectRepository.Find("Algo").Clone();
11. Надо сделать возможность не указывать автора явно, а на основе currentUser через Singleton, чтобы иметь глобальную видимость.
        Причем надо обеспечить иммутабельность автора, потому что currentUser может поменяться
12. Сделать в EducationProgram массив списков, где длина массива - кол-во семестров, а в списках ссылки на предметы, которые хранятся в репозитории предметов



////// Development
7. Внедрить ResultType в
    1) При добавлении item в репо, который уже есть

валидаторы