Репозитории:
1. мапа вида string: specialObject
2. find по id
3. добавление?




пока попробуем концепцию при создании объекта user, lection они в констуктор



// Надо раскрыть в классы
enum SubjectType
{
    Exam,
    Pass
}




public Main()
{

User mayatin = new User("Mayatin");             // name
User khartanovich = new User("Khartanovich");   // name
User currentUser = mayatin;  // См. пункт 3

EducationProgramm ep = new EducationProgramm("IS", 4, mayatin); // name, NumberOfSemesters, head

Subject algo = new Subject("Algo", SubjectType.Exam, mayatin);          // name, subjectType, author
Subject english = new Subject("English", SubjectType.Pass, mayatin);    // name, subjectType, author
Subject discrete = algo.Clone();   // См. пункт 4
discrete.ChangeName("Discrete", currentUser)    // См. пункт 5, 7

currentUser = khartanovich;

Lection algoLectionOne = new Lection("Lection Number One", "Something Useful", "blablabla", khartanovich)  // name, brief_info, content, author
Lection algoLectionTwo = algoLectionOne.Clone();
algoLectionTwo.ChangeName("Lection Number Two", currentUser);

algo.AddLection(algoLectionOne);
algo.AddLection(algoLectionTwo);


LabWork labOne = new LabWork("Laba One", "6 problems", "criteria", 10, khartanovich)    // name, description, criteria, score, author
LabWork labTwo = labOne.Clone();
labTwo.ChangeName("Laba Two", currentUser);
labTwo.ChangeDescription("8 problems", currentUser);

discrete.AddLab(labOne);
discrete.AddLab(labTwo);





// А что если мы будем добавлять предметы в оп в самом конце и когда происходит добавление, то оп будет чекать 100 баллов ли там или нет?
ep.AddSubject(algo);
ep.AddSubject(english);
ep.AddSubject(discrete);
}


!!!!!! ИНДЕИ !!!!!!!
1. А что если мы будем добавлять предметы в оп в самом конце и когда происходит добавление, то оп будет чекать 100 баллов ли там или нет?
2. Надо раскрыть enum SubjectType в классы
        Кол-во баллов должно быть unmutable - бизнес-логикка
3. А что если ввести в тестах (ну или в продакшене) переменную User currentUser, которая будет отвечать за то, под каким юзером идет редактирование?
       Это позволит не вводить постоянно пользователя плюс упростить проверку на то, кто редактирует
4. Нужно сохранить единый класс Subject, при этом, чтобы в клонированном объекте было parentId
        поэтому заюзаем nullable-поле: public int? ParentId
5. Очень не нравится, что для каждого поля свой метод. Билдер?
6. Насчет невозможность изменять некоторые поля после клонирования: а что если основной смысл клонирования будет в том, что
        действительно мы не можем изменять неизменяемые поля, поэтому и делаем например лабу на основе другой,
        а поля для изменения будут действительно изменяться
7. Можно для User сделать паттерн singleton, чтобы обеспечить глобальную точку доступа к currentUser. тогда не нужно будет передавать постоянно currentuser